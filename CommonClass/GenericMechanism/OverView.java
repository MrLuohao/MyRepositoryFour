package CommonClass.GenericMechanism;

public class OverView {
    /*
    1.没有采用泛型的集合，表面结果看似不一样，其实底层都是Object类型，类型都是一样的，所以我们为了获取最真实的数据类型就必须做强转，就容易出现类型转换异常的错误
    2.为了避免这种错误的发生，我们采用泛型的概念
    3.泛型就是用<限制集合里添加的数据类型>的形式来规范集合里面所能添加的元素类型，这是如果其他的元素类型添加就会报错
    4.泛型的本质就是形式化参数，相当于用指定的类型当作形式参数占位置，把类型当作形参传递
    5.实例化对象的时候必须是引用数据类型，不能是基本数据类型
    6.泛型类型定义过后，所以泛型类的地方都当作定义泛型的类型来处理，没有定义的地方就当作Object类型才处理
    7.在静态方法中使用泛型参数的时候，需要我们把静态方法定义为泛型方法（因为泛型需要在创建对象的时候指定泛型类型，而如果加了static关键字过后就意味着可以类名.调用，就可以不创建对象调用该方法，这样的话就互相矛盾了）
    8.通配符的使用：1.有时候我们希望传入的类型在一个指定的范围内，此时就可以使用泛型通配符了
                   2.泛型中三种通配符形式：<？>无限指通配符：表示我们可以传入任意类型的参数
                                          <? extends E>表示类型的上界是E，只能是E或者E的子类
                                          <? super E>表示类型的下界是E，只能是E或者E的父类
     */
}
